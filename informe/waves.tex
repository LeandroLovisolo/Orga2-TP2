Este filtro consiste en obtener los pixeles de la imagen original y aplicarle una serie de cuentas para luego insertar el resultado en la imagen de destino. Las cuentas que se realizan son las siguientes. \\

\begin{itemize}
	\item $prof = ( x\_scale*sin\_taylor(i/8.0) + y\_scale*sin\_taylor(j/8.0) )/2$. Donde $sin\_taylor$ es una función que calcula el seno de $x$ a travez de una aproximación, y $x\_scale$,$y\_scale$ son parámetros de entrada de la función.
	\item Si el valor optenido es mayor a $255$ el resultado es $255$.
	\item Si el contenido es menor a $0$ el resultado es $0$.
	\item En otro caso el se trunca el resultado.
\end{itemize}

\subsubsection{Pseudo codigo del algoritmo en C:}

\begin{pseudocodigo}
   \FOR {alto de la imagen}
		\FOR {ancho de la imagen}
			\STATE
			\STATE $prof = ( x\_scale*sin\_taylor(i/8.0) + y\_scale*sin\_taylor(j/8.0) )/2$ 
			\STATE $newValue = prof*g\_scale + src\_matrix[i][j]$ 
			\STATE
			\IF {$newValue > 255$}
				\STATE $newValue = 255$
			\ELSE 
				\IF{$newValue < 0$}
					\STATE $newValue = 0$
				\ENDIF 
			\ENDIF
			\STATE $dst\_matrix[i][j] = floor(newValue)$ 
		\ENDFOR
	\ENDFOR
\end{pseudocodigo}

$sin\_taylor(x)$:


\begin{pseudocodigo}
   \FOR {alto de la imagen}
		\FOR {ancho de la imagen}
			\STATE
			\STATE $pi	= 3.14159265359$
			\STATE $k 			= floor(x/(2*pi))$
			\STATE $r 		= x - k*2*pi$
			\STATE $x 				= r - pi$
			\STATE $y 		= x - (pow(x,3)/6) + (pow(x,5)/120) - (pow(x,7)/5040)$
			\STATE
			\STATE devolver $y$
			\STATE
		\ENDFOR
	\ENDFOR
\end{pseudocodigo}

\subsubsection{Idea general:}
La motivación de utilizar assembler para la resolución de esta aplicación es fundamentalmente la aplicación de las herramientas SIMD para mejorar la performanse del algoritmo. Teniendo en cuenta que el mismo trabaja haciendo iteraciónes sobre los píxeles de una imagen y procesando los mismos, si podemos procesar más de un pixel por iteración mejoramos de forma significativa la performance de la aplicación.\\

La idea principal fue implementar el algoritmo utilizando los registros $xmm$ para poder procesar 16 píxeles por iteración. Ante esta idea, el problema que nos surgio fue el siguiente:\\

Como se puede ver en el pseudocodigo debemos llamar a la función $sin\_taylor(j/80.0)$ y $sin\_taylor(i/80.0)$, donde $(i,j)$ hacen referencia a la posición del pixel dentro de la matriz de la imagen. No podemos asumir nada en cuanto al valor de $j$ e $i$, incluso, estos pueden ser tan grandes como quieran, dependiendo el tamaño de la imagen, haciendo en ciertos casos que el algoritmo en assembler tenga fallas si se superara la precisión de un byte. 

El algoritmo en C esta implementado con float, lo cual es una precisión razonable para las dimensiones de imagenes con que se suele trabajar, es por esto que decidimos trabajar los datos con doubleword's, codificandolos como punto flotante de simple precisión.

Al trabajar con los datos en esta precisión lo que tenemos es que para trabajar con $16$ pixeles necesitamos $4$ registros $xmm$ para cargar los indices de las columnas a los que estos pertenecen, más otro registro para cargar el valor empaquetado del indice de la fila a la que pertencen. Si miramos la función $sin\_taylor$ veremos que necesitamos entonces, 5 registros para el acumulador de la cuenta, 5 registros para mantener el valor original mientras que en otros 5 registros se van calculando cada termino del polinomio. Esto nos da una suma de $15$ registros $xmm$. hay maneras de poder trabajar con 16 pixeles reutilizando registros y llamando a memoria, pero como justamente no queremos hacer llamados a memoria, nos parecio más eficiente procesar 8 pixeles por iteración y utilizar los registros $xmm$ sobrantes para precargar valores que seran utilizados en todas las iteraciones. \\

\subsubsection{Pre-ciclo principal:}
una vez visto esto, pasemos a nombrar todos los registros que pre-seteamos antes de empezar el ciclo, y que luego serán utilizado dentro del mismo.

estos valores son:
\begin{itemize}
	\item $xmm0$ $\Rightarrow$ $x\_scale$;$x\_scale$;$x\_scale$;$x\_scale$
	\item $xmm1$ $\Rightarrow$ $y\_scale$;$y\_scale$;$y\_scale$;$y\_scale$
	\item $xmm2$ $\Rightarrow$ $g\_scale$;$g\_scale$;$g\_scale$;$g\_scale$
	\item $xmm3$ $\Rightarrow$ $pi$;$pi$;$pi$;$pi$
	\item $xmm4$ $\Rightarrow$ $2.0$;$2.0$;$2.0$;$2.0$
	\item $xmm5$ $\Rightarrow$ $3$;$2$;$1$;$0$
	\item $xmm6$ $\Rightarrow$ $7$;$6$;$5$;$4$
	\item $xmm7$ $\Rightarrow$ $6.0$,$6.0$;$6.0$;$6.0$
	\item $xmm8$ $\Rightarrow$ $120.0$;$120.0$;$120.0$;$120.0$
	\item $xmm9$ $\Rightarrow$ $5040.0$;$5040.0$;$5040.0$;$5040.0$
\end{itemize}

\subsubsection{Descripción del ciclo:}
\begin{itemize}
	\item El primer paso realizado dentro de la iteración es guardar en $2$ registros $xmm$ los valores de los indices de los pixeles que se van a procesar, Sea $(i,j)$ el primero de los $8$ pixeles que seran procesados, los valores que se necesitan guardar son: $j$,$j+1$,$j+2$,$j+3$,$j+4$,$j+5$,$j+6$,$j+7$,$j+8$, y también el valor de $i$, el cual es el mismo para todos los pixeles ya que estamos trabajando sobre una misma fila.
	
	Para hacer esto, necesitamos los siguientes pasos:
	\begin{itemize}
	 	\item Copiamos el valor de los registros $xmm5$ y $xmm6$ a los registros $xmm10$ y $xmm11$ utilizando la instrucción MOVDQU, obteniendo en ellos los valores del $0$ al $7$.
	 	\item En un registro $xmm$ se le pone en todos sus doubleword's el valor de $j$ utilizando la instrucciones MOVQ que mueve un doubleword en la parte baja del registro $xmm$ y extiende el resto del registro con $0$'s y SHUFPS que lo expande en las demas doubleword's del registro. 
	 	\item Se lo codifica a punto flotante con la instrucción CVTDQ2PS. 
	 	\item Luego se procede a sumarle a los registros $xmm10$ y $xmm11$ el registro donde empaquetamos el valor de $j$, para esto Utilizamos la instrucción ADDPS que realiza la suma empaquetada de doubleword codificados como puntos flotantes.
	\end{itemize}
	
	(El algoritmo procesa mas adelante el valor de $i$, por lo que en esta instancia no hacemos nada con el).

	\item El segundo paso a realizar es dividir los valores de los $j$'s por $8$, pero como tenemos ya en un registro $xmm$ empaquetado el número $2.0$ como doubleword's, lo que hacemos es dividir tres veces por este registro utilizando la intrucion DIVPS.

	\subsubsection{función $Sin\_taylor$:}
	\item  El próximo paso es implementarle a estos valores la funcion $sin\_taylor$. Para esto copiamos a los registros $xmm12$ y $xmm13$ el contenido de los registros $xmm10$,$xmm11$ respectivamente, y seguimos los siguientes pasos:

	\begin{itemize}
		\item Dividimos los valores de cada pixel por $2*pi$. Como tenemos estos valores en los registros $xmm3$ y $xmm4$ utilizamos nuevamente las intrucciones DIVPS para dividir $xmm12$ y $xmm3$ por los registros anteriores, y luego aplicamos las instrucciones CVTTPS2DQ y CVTTPS2DQ para obtener la parte entera.

		\item El proximo paso de la funcion de taylor es restarle a los valores originales el resultado anterior previamente multiplicado por $2*pi$. Primero, multiplicamos utilizando la instrucción MULPS, los registros $xmm3$ y $xmm4$ a los registros $xmm12$,$xmm13$ donde estan los resultados anteriores, y luego a los registros $xmm10$ y $xmm11$ donde se encuentran los valores originales le restamos los registros $xmm12$,$xmm13$ correspondientementes utilizando la instrucción  SUBPS.\\
		En este paso hemos perdido los valores originales que teniamos empaquetados en $xmm10$ y $xmm11$ pero esto no nos importa ya que no los necesitamos más.

		\item Luego vamos a restarle a lo recien obtenido el valor de $pi$ empaquetado en el registro $xmm3$, y a continuación una seguidilla de pasos repetidos de forma casi igual, por lo que consideramos mejor una explicación general para estos pasos, y no una lectura tediosa y repetitiva de la realización de los mismos.

		Estos pasos son utilizados para obtener el valor siguiente, $Y = X - X^3/6 + X^5/120 - X^7/5040$ en cada doubleword de dos registros $xmm$ de forma empaquetada ($X$ hace referencia a los valores obtenidos mediante los pasos anteriores que estan empaquetados en los registros $xmm12$ y $xmm13$).
		Para realizar esta cuenta, se guarda el valor de $xmm12$,$xmm13$ en dos registros $xmm$ para poder salvarlos, luego se copian de vuelta estos valores en otros dos registros $xmm$ que seran utilizados como acumulador. y lo siguiente a realizar es ir multiplicando y dividiendo estos registros para obtener cada uno de los terminos del polinomio y sumarselo o restarselo a los registros acumuladores para ir teniendo el valor del polinomio en los acumuladores. Los dividendos utilizados estan ya pre-seteados en los registros $xmm7$,$xmm8$,$xmm9$ de forma empaquetada codificados en punto flotante.
	\end{itemize}

	\item Una vez que tenemos el $sin\_taylor$ para los indices $j$'s de forma empaquetada en los registros $xmm12$,$xmm13$, pasamos a empaquetar el indice $i$ en el registro $xmm10$ y realizamos los mismos pasos anteriores para obtener el $sin\_taylor$ de $i/8.0$. Con lo cual al final de los pasos conseguimos en el registro $xmm11$ el valor empaquetado en doubleword's de $sin\_taylor$ para el indice $i/8.0$, (el cual es el mismo valor para todos los pixeles por pertenecer a la misma fila).

	\item Lo siguiente, es obtener el valor de $prof(i,j)$. Para esto, primero le multiplicamos a los registro $xmm12$,$xmm13$ donde estan empaquetados los taylor's de los indices $j$'s$/8.0$ el registro $xmm1$, que es donde esta empaquetado el valor de $y\_scale$, y le multiplicamos  a $xmm11$ el registro $xmm0$ ya que en este esta empaquetado el valor de $x\_scale$. Una vez realisado esto, le sumamos a los registros $xmm12$,$xmm13$ el registro $xmm11$ y los dividimos por el registro $xmm4$ que es el que tiene el valor $2.0$ empaquetado en doubleword.

	De esta menera queda guardado en los registros $xmm12$,$xmm13$ la funcion $Prof(i,j)$ de los indices de los pixeles que se estan procesando. En $xmm12$ estan los valores para los pixeles de las pisiciones $(i,j)$ hasta $(i,j+3)$ y en $xmm13$ estan los valores para los pixeles de las posiciones $(i,j+4)$ hasta $(i,j+7)$

	\item El siguiente paso consiste en traer los valores de los pixeles de la memoria y desempaquetarlos guardando el valor en los registros $xmm14$ y $xmm15$ (en $xmm14$ se guardan los primeros $4$ pixeles y en $xmm15$ el resto).

	Teniendo estos valores hacemos la suma de $xmm12$ con $xmm14$ y $xmm13$ con $xmm15$ y tenemos el valor ya listo para ser empaquetado y guardado en el destino.

	Teniendo en cuenta que este valor puede ser mayor a $255$ o menor a $0$ para empaquetar utilizamos la instrucción PACKUSDW que empaqueta saturando integer's sin signo, dejando asi en $255$ todos aquellos valores mayores al mismo y en $0$ a los valores negativos.

\end{itemize}

\subsubsection{Comparación con el lenguaje C}

Mirando el pseudocodigo del algoritmo en C vemos para empezar que la cantidad de iteraciones es 8 veces mayor en C que en assembler al utilizar SIMD. ya que mientras que en C se procesa de a un solo pixel por vez en assembler se procede a procesar 8.

Otro aspecto a tener en cuenta es que en la implementación en assembler tenemos que obtener a partir de la posición del primer pixel los valores de los $j$'s para los otros $7$ pixeles que se van a procesar, si vien esto en C no hay que hacerlo, el costo de este paso del algoritmo esta esta compensado ya que al realizar 8 veces menos cantidad de iteraciones hay que avanzar ocho veces menos los contadores. Podemos concluir entonces que en ciertos casos, si vien paralelizar supone realizar algunos pasos extras, hay que ver si los mismos son compensados o no. pueden existir casos donde la cantidad de pasos extras a compensar sean demasiados y termine bajando la performance comparandolo con algoritmos comunes.

Tambien podemos ver que en la version C cada vez que se llama a la funcion $sin\_taylor$, se define el valor de $pi$ mientras que en la implementacion assembler el mismo ya esta predefinido antes de comenzar el ciclo, lo mismo pasa con los valores $6$, $120$ y $5040$. esto mejora la performance, pero no se lo puede considerar como una mejora de SIMD ya que lo mismo podria ser facilmente aplicado en la version C del algoritmo.\\

\underline{\textbf{Consideraciones a la hora de comparar la versión C con assembler:}}

Tengamos en cuenta para la comparación de ambas implementaciones que en C por cada pixel se hace la llamada a la funcion $sin\_taylor$ que como sabemos supone ciertos pasos para satisfacer la convencion C y pasarle los parametros a la misma, Esto lo convierten mas lento que si la misma funcion estuviera definida dentro del mismo algoritmo.

También pasa que tanto en la implementación C como en la implementación assembler, podriamos mejorarlas calculando la funcion $sin\_taylor$($i/8.0$) una sola vez por cada fila, de esta manera se reduce significativamente la llamada a la función, mejorando la performanze. En este punto es importante ver que esta mejora es $8$ veces menos significatica para assembler que para C, esto se debe a que en el mismo ya se procesan 8 pixeles por vez. Por lo que vemos que mismo en algoritmos ineficientes puede pasar que al paralelizar estemos obteniendo de por si un algoritmo mejorado y aplicable a la versión no paralelizada del mismo sin siquiera saberlo.

\subsubsection{Rendimiento}

Observamos las siguientes cantidades de ciclos y ticks de reloj al realizar 100 iteraciones de ambas implementaciones con una imagen cuadrada de lado 512.
\begin{center}
    \begin{tabular}{|l|l|l|l|}
        \hline
        Medición & Implementación C & Implementación assembler & Relación \\
        \hline
        Ticks    & 40908368256      & 960464334            & $2.35\%$ \\
        Ciclos   & 409083712        & 9604643              & $2.35\%$ \\
        \hline
    \end{tabular}
\end{center}