\documentclass[a4paper,10pt,twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-ucroman,es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algorithmic}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}


% Evita que el documento se estire verticalmente para ocupar
% el espacio vacío en cada página.
\raggedbottom


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 2, Organización del Computador II}
\rhead{Belloli, Lovisolo, Petaccio}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudocodigo}
    {\vspace{0.5em} \begin{algorithmic}}
    {\end{algorithmic} \vspace{0.5em}}

% Alinear comentarios a la derecha
\renewcommand{\algorithmiccomment}[1]{\hfill \{#1\}}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Macros de tikz - Inicio %%%%%%%%%%
% Uso: \registroCuatro{etiqueta}{x}{y}{a4}{a3}{a2}{a1}
\newcommand{\registroCuatro}[7]{
    \ifthenelse{\equal{#1}{}}{}{
        \draw (#2, {#3 + 0.5}) node[anchor=east]{#1};
    }

    \draw   (#2, #3) rectangle +(4, 1) +(2, 0.5) node{#4}
          ++(4, 0)   rectangle +(4, 1) +(2, 0.5) node{#5}
          ++(4, 0)   rectangle +(4, 1) +(2, 0.5) node{#6}
          ++(4, 0)   rectangle +(4, 1) +(2, 0.5) node{#7};          
}

% Uso: \registroOcho{etiqueta}{x}{y}{a8}{a7}{a6}...{a1}
\newcommand{\registroOcho}[9]{
    \def\etiqueta{#1}
    \def\x{#2}
    \def\y{#3}
    \def\aviii{#4}
    \def\avii{#5}
    \def\avi{#6}
    \def\av{#7}
    \def\aiv{#8}
    \def\aiii{#9}
    \registroOchoX    
}
\newcommand{\registroOchoX}[2]{ % Auxiliar - no usar directamente
    \def\aii{#1}
    \def\ai{#2}
    \ifthenelse{\equal{\etiqueta}{}}{}{
        \draw (\x, {\y + 0.5}) node[anchor=east]{\etiqueta};
    }
    \filldraw[fill=white]
        (\x, \y) rectangle +(2, 1) +(1, 0.5) node{\aviii}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\avii}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\avi}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\av}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\aiv}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\aiii}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\aii}
        ++(2, 0) rectangle +(2, 1) +(1, 0.5) node{\ai};
}


% Uso: \registroDieciseis{etiqueta}{x}{y}{a16}{a15}{a14}...{a1}
\newcommand{\registroDieciseis}[9]{
    \def\etiqueta{#1}
    \def\x{#2}
    \def\y{#3}
    \def\axvi{#4}
    \def\axv{#5}
    \def\axiv{#6}
    \def\axiii{#7}
    \def\axii{#8}
    \def\axi{#9}
    \registroDieciseisX
}
\newcommand{\registroDieciseisX}[9]{ % Auxiliar - no usar directamente
    \def\ax{#1}
    \def\aix{#2}
    \def\aviii{#3}
    \def\avii{#4}
    \def\avi{#5}
    \def\av{#6}
    \def\aiv{#7}
    \def\aiii{#8}
    \def\aii{#9}
    \registroDieciseisXX
}
\newcommand{\registroDieciseisXX}[1]{ % Auxiliar - no usar directamente
    \def\ai{#1}
    \ifthenelse{\equal{\etiqueta}{}}{}{
        \draw (\x, {\y + 0.5}) node[anchor=east]{\etiqueta};
    }
    \filldraw[fill=white]
        (\x, \y) rectangle +(1, 1) +(0.5, 0.5) node{\axvi}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\axv}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\axiv}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\axiii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\axii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\axi}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\ax}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\aix}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\aviii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\avii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\avi}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\av}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\aiv}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\aiii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\aii}
        ++(1, 0) rectangle +(1, 1) +(0.5, 0.5) node{\ai};
}
%%%%%%%%%% Macros de tikz - Fin %%%%%%%%%%


%%%%%%%%%% Macros misceláneos - Inicio %%%%%%%%%%
\newcommand{\xmm}[1]{\texttt{XMM#1}}
\newcommand{\rax}{\texttt{RAX}}
\newcommand{\rbx}{\texttt{RBX}}
\newcommand{\rcx}{\texttt{RCX}}
\newcommand{\rdx}{\texttt{RDX}}
\newcommand{\rbp}{\texttt{RBP}}
\newcommand{\rsp}{\texttt{RSP}}
\newcommand{\reg}[1]{\texttt{R#1}}
\newcommand{\asm}[1]{\texttt{\uppercase{#1}}}
%%%%%%%%%% Macros misceláneos - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 2
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Organización del Computador II
\end{Large}

\vspace{1cm}

Primer Cuatrimestre de 2013

\vspace{4cm}

Grupo: \textbf{Panceta y Mozzarella}

\vspace{0.5cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Laouen Louan Mayal Belloli  & 134/11 & lao.facu@gmail.com\\
Leandro Lovisolo      		& 645/11 & leandro@leandro.me\\
Lautaro José Petaccio 		& 443/11 & lausuper@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

El objetivo de este trabajo es experimentar con el set de instrucciones SIMD de la arquitectura IA-32 de Intel. 

Con este propósito, implementamos una serie de filtros gráficos que operan sobre imágenes RGB y en escala de grises. Para cada filtro escribimos una implementación de referencia en lenguaje C, sin ningún tipo de optimización, y otra implementación en lenguaje assembler haciendo uso de las instrucciones SIMD siempre que fuera posible. Finalmente, evaluamos el rendimiento de ambas implementaciones de cada filtro, y discutimos las mejoras observadas.

En la siguiente sección analizamos cada una de las implementaciones y describimos en detalle las instrucciones SIMD usadas en cada caso.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Desarrollo                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Desarrollo}

\subsection{Recortar}

\input{recortar}

\subsection{Halftone}

\input{halftone}

\subsection{Umbralizar}

\input{umbralizar}

\subsection{Colorizar}

\input{colorizar}

\subsection{Efecto plasma}

\input{waves}

\subsection{Rotar}

\input{rotar}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Resultados                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Resultados}

Resumimos a continuación las mejoras de rendimiento obtenidas al aplicar instrucciones SIMD. El gráfico que sigue presenta el porcentaje del tiempo de ejecución de las implementaciones assembler respecto de las implementaciones C. Cuanto más pequeña sea la barra, mayor es la mejora de rendimiento obtenida.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[>=stealth]
        % Porcentajes
        \def\recortar  {6.43}
        \def\halftone  {6.64}
        \def\umbralizar{8.92}
        \def\colorizar {2.28}
        \def\plasma    {2.35}
        \def\rotar     {41.17}

        \def\escala    {0.2}

        % Recortar
        \filldraw[fill=gray] (1,    0) rectangle ++(1, {\recortar * \escala});
        \draw                (1.5,  0) node[anchor=north]{Recortar};
        \draw                (1.5, {\recortar * \escala}) node[anchor=south]{\recortar\%};

        % Halftone
        \filldraw[fill=gray] (3,    0) rectangle +(1, {\halftone * \escala});
        \draw                (3.5,  0) node[anchor=north]{Halftone};
        \draw                (3.5, {\halftone * \escala}) node[anchor=south]{\halftone\%};

        % Umbralizar
        \filldraw[fill=gray] (5,    0) rectangle +(1, {\umbralizar * \escala});
        \draw                (5.5,  0) node[anchor=north]{Umbralizar};
        \draw                (5.5, {\umbralizar * \escala}) node[anchor=south]{\umbralizar\%};

        % Colorizar
        \filldraw[fill=gray] (7,    0) rectangle +(1, {\colorizar * \escala});
        \draw                (7.5,  0) node[anchor=north]{Colorizar};
        \draw                (7.5, {\colorizar * \escala}) node[anchor=south]{\colorizar\%};

        % Plasma
        \filldraw[fill=gray] (9,    0) rectangle +(1, {\plasma * \escala});
        \draw                (9.5,  0) node[anchor=north]{Plasma};
        \draw                (9.5, {\plasma * \escala}) node[anchor=south]{\plasma\%};

        % Rotar
        \filldraw[fill=gray] (11,   0) rectangle +(1, {\rotar * \escala});
        \draw                (11.5, 0) node[anchor=north]{Rotar};
        \draw                (11.5, {\rotar * \escala}) node[anchor=south]{\rotar\%};   

        % Ejes
        \draw [->] (0, 0) -- +(0,  10);
        \draw      (0, 0) -- +(13, 0);
    \end{tikzpicture}
    \caption{Tiempo de ejecución de las implementaciones assembler respecto a C.}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusión}

A lo largo de este trabajo obtuvimos mejoras de rendimiento significativas de manera consistente al hacer uso de instrucciones SIMD. 

Identificamos dos posibles focos de aplicación para este juego de instrucciones: la paralelización de cómputos y el acceso a memoria de a bloques de datos contiguos. Observamos que en los casos que se logró acceder a más de un dato en memoria a la vez obtuvimos las ganancias de rendimiento más grandes.

En aquellos casos en los que no fue posible acceder a más de un dato en memoria a la vez, aún así obtuvimos grandes mejoras de rendimiento al paralelizar el procesamiento de los datos leídos en forma secuencial, aunque más pequeñas en comparación con los casos en los que esto sí fue posible.

Además, observamos que el código assembler generado por el compilador gcc (con nivel de optimización por defecto) produce una cantidad adicional de accesos a memoria al guardar en la pila los parámetros de las funciones y variables locales, que producen la penalidad de rendimiento correspondiente. Esto es especialmente evidente cuando el código C hace muchas llamadas a funciones, como en el caso de los filtros que invocan funciones auxiliares en el ciclo que itera sobre todos los píxeles de la imagen.


\end{document}