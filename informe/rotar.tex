El filtro rotar es el menos capacitado para paralelización. Esta dificultad proviene de la imposibilidad de traer bytes y procesarlos simultaneamente, debido a que el valor de cada pixel en la imagen destino se obtiene calculando, según su posición, qué pixel corresponde de la imagen fuente, lo que implica traer uno a uno los pixeles de la imagen fuente para colocarlos en en lugar indicado en la imágen destino.

Analizando el algoritmo, llegamos a la conclusión de que la mejor manera de explotar la simultaneidad que nos brinda las instrucciones SIMD, es utilizarlas para calcular las posiciones de dónde sacar el pixel para colorcarlo en la imagen destino. 

Inicialmente este proceso fue realizado utilizando single precision floats para poder aprovechar SIMD al máximo y realizar cálculos para conseguir las posiciones de donde sacar los pixeles a la vez. Este intento se vió frustrado al correr el filtro y compararlo contra las imágenes provistas por la cátedra. Si bien la imagen coincidía visualmente, se encontraron errores en 27 pixeles. Un análisis de estos pixeles pusieron en evidencia un problema de precisión, el cual se intentó arreglar utilizando la instrucción roundps sin conseguir mejores resultados. Se solucióno el problema realizando los cálculos usando double precision floats con SIMD para luego convertirlos a floats y finalmente convertirlos a enteros para poder funcionar como posición.

Para optimizar la implementación, se realiza el cálculo de cx, cy y $\sqrt[2]{2}/2$ al inicio del programa.

El programa recorre las posiciones de la imagen destino y les asigna su valor según su posición.

\subsubsection{Descripción del ciclo}
El ciclo comienza poniendo en 0 mediante la instrucción por el registro xmm7 el cuál se encargará de acumular 16 bytes con los valores correspondientes de los píxeles.

 El algoritmo continúa con un pequeño ciclo interno el cuál se encarga de poner en 2 registros temporales los valores de las posiciones x e y de 4 pixeles sucesivos. Una vez realizado esto, para poder trabajar con los 4 pixeles utilizando doubles, se mueve el contenido de estos registros a registros xmm dónde se los convierte y se los almacena 4 registros xmm, 2 con los 2 doubles más bajos y altos de las coordenadas x y 2 con los 2 doubles más bajos y altos de las coordenadas y.

Se opera sobre los doubles utilizando instrucciones SIMD, obteniedo los valores u y v, es decir, los valores x e y respectivamente de dónde conseguir el pixel a poner en la imágen fuente.

Al finalizar el cálculo se convierten de doubles a floats y de floats a enteros y vuelven a colocar las coordenadas x en un registro xmm y las coordenadas y en otro cómo estaban antes.

Después de esta conversión, se pasa a un pequeño ciclo el cuál se encarga de tomar cada coordenada, ver si cumplen las restricciones del cálculo para u y v, y colocar en el caso de que se cumpla, en un acumulador, el valor del pixel que tenga en la posición en la imagen fuente y si no, un 0.

Al terminar este ciclo, se agregan los valores de estos 4 bytes al el acumulador principal que se creó al comienzo del ciclo y se vuelve a ciclar realizando el mismo proceso hasta llenar el acumulador con los valores correspondientes de los 16 bytes o 16 pixeles contiguos.

En el final de cada iteración del ciclo princiapl, se checkea la posición de la imagen en la que se está (por si ya se ha terminado de recorrerla o se es necesario correr para atrás para agarrar 16 pixeles exactos) y si se ha llenado el acumulador. Si el acumulador se llena (habiendo pasado 4 ciclos) se mueven los 16 bytes a la imagen destino, economizando el movimiento de datos.

\subsubsection{Comparación con el lenguaje C}
